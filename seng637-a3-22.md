**SENG 637 - Software Testing, Reliability, and Quality**

**Lab. Report \#3 – Requirements-Based Test Generation**

| Group: 22      |
|-----------------|
| Student 1 Jeremy Sugimoto                |   
| Student 2 Matt De Filippo             |   
| Student 3 Momin Muhammad               |   
| Student 4 Redge Santillan                |   
| Student 5 Shad Sajid               |   

# Table of Contents

1. [Introduction](#1-introduction)
2. [Manual data-flow coverage calculations for Range.getLowerBounds and DataUtilities.CalculateColumnTotal methods](#2-manual-data-flow-coverage-calculations-for-rangetgetlowerbounds-and-datautilitiescalculatecolumntotal-methods)
3. [A detailed description of the testing strategy for the new unit test](#3-a-detailed-description-of-the-testing-strategy-for-the-new-unit-test)
4. [A high level description of five selected test cases you have designed using coverage information, and how they have increased code coverage](#4-a-high-level-description-of-five-selected-test-cases-you-have-designed-using-coverage-information-and-how-they-have-increased-code-coverage)
5. [A detailed report of the coverage achieved of each class and method (a screen shot from the code cover results in green and red color would suffice)](#5-a-detailed-report-of-the-coverage-achieved-of-each-class-and-method-a-screen-shot-from-the-code-cover-results-in-green-and-red-color-would-suffice)
6. [Pros and Cons of coverage tools used and Metrics you report](#6-pros-and-cons-of-coverage-tools-used-and-metrics-you-report)
7. [A comparison on the advantages and disadvantages of requirements-based test generation and coverage-based test generation](#7-a-comparison-on-the-advantages-and-disadvantages-of-requirements-based-test-generation-and-coverage-based-test-generation)
8. [A discussion on how the team work/effort was divided and managed](#8-a-discussion-on-how-the-team-workeffort-was-divided-and-managed)
9. [Any difficulties encountered, challenges overcome, and lessons learned from performing the lab](#9-any-difficulties-encountered-challenges-overcome-and-lessons-learned-from-performing-the-lab)
10. [Comments/feedback on the lab itself](#10-commentsfeedback-on-the-lab-itself)



# 1 Introduction

Text…

# 2 Manual data-flow coverage calculations for Range.getLowerBounds and DataUtilities.CalculateColumnTotal methods

`Range.getLowerBounds()`

![image](https://github.com/rrsantillan/seng637-a3-group22/assets/132379865/253eb08d-ccd6-48b8-8c6d-6d80af983d96)


##### Defs, uses, and du-pairs

|               |                                |
| ------------- | ------------------------------ |
| **defs**:     | def(2) = {msg}              |
| **uses**:     | use(1) = {lower,upper}      |
|               | use(2) = {lower,upper}      |
|               | use(3) = {msg}      |
|               | use(4) = {lower}      |
| **du-pairs**: | for msg: (2,3) |
|               | for lower: (1,2),(1,4)|
|               | for upper: (1,2),(1,4)|


#### DU-pair coverage calculations per test case
| Variable | Def at node (n) | dcu(v,n) | dpu(v,n)  |
|----------|-----------------|----------|-----------|
|   lower  | Prior to function|        |   (1,2),(1,4)  |       
|   upper  | Prior to function|        |   (1,2),(1,4)  |
|   msg    |        2        |   (2,3)  |           |


| Test Case | Execution path | DU-pairs covered | CUc + PUc | All uses coverage % |
|-----------------------------|------------------|------------------|-----------|---------------------|
|`lowerBoundShouldBeNegativeTen`| (1,4)            |      (1,4)        |     (1,4)      |        33.33%             |
|`lowerBoundWithLargeRange`     | (1,4)            |      (1,4)       |      (1,4)     |     33.33%                |
|`shouldThrowExceptionWhenLowerIsGreaterThanUpper` |     (1,2,3)       | (2,3)| (1,2),(2,3) | 66.66%  |

#### Total

Cuc + PUc = 3

CU +PU = 3

All-uses coverage = 100%

#### 2. `DataUtilities.calculateColumnTotal(Values2D data, int column)`

![image](https://github.com/rrsantillan/seng637-a3-group22/assets/132379865/afd48c53-f22d-4f32-aa1e-9c0f16fe6d93)



##### Defs, uses, and du-pairs

|               |                                                       |
| ------------- | ----------------------------------------------------- |
| **defs**:     | def(1) = {data, column}                               |
|               | def(3) = {total, rowCount, r}                         |
|               | def(5) = {n}                                          |
|               | def(6) = {total}                                      |
|               | def(7) = {r}                                          |
| **uses**:     | use(2) = {data}                                       |
|               | use(3) = {data}                                       |
|               | use(4) = {r, rowCount}                                |
|               | use(5) = {data, r, column, n}                         |
|               | use(6) = {total, n}                                   |
|               | use(7) = {r}                                          |
|               | use(8) = {total}                                      |
| **du-pairs**: | for data: (1, 2), (1, 3), (1, 5)                      |
|               | for column: (1, 5)                                    |
|               | for total: (3, 6), (3, 8), (6, 6), (6, 8)             |
|               | for rowCount: (3, 4)                                  |
|               | for r: (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7) |
|               | for n: (5, 5), (5, 6)                                 |

##### DU-pair coverage calculation per test case

| Variable | Def at node (n) | dcu(v, n) | dpu(v, n)        |
| -------- | --------------- | --------- | ---------------- |
| data     | 1               | {2, 3, 5} | {}               |
| column   | 1               | {5}       | {}               |
| r        | 3               | {5, 7}    | {(4, 5), (4, 8)} |
| r        | 7               | {5, 7}    | {(4, 5), (4, 8)} |
| rowCount | 3               | {}        | {(4, 5), (4, 8)} |
| total    | 3               | {6, 8}    | {}               |
| total    | 6               | {6, 8}    | {}               |
| n        | 5               | {6}       | {(5, 6), (5, 7)} |
|          | Total           | CU = 13   | PU = 8           |

| Test case                                        | Execution path                                   | DU-pairs covered                                                                                                                       | CUc + PUc                                                                                                 | All-uses coverage % |
| ------------------------------------------------ | ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | ------------------- |
| `calculateColumnTotalAllRowsFirstColumn`         | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalAllRowsMiddleColumn`        | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalAllRowsLastColumn`          | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalWithMaxValueAndFirstColumn` | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalWithMinValueAndFirstColumn` | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalWithMaxValueColumn`         | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalWithMinValueColumn`         | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalWithSumOf0AndFirstColumn`   | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |

**Total**

CUc + PUc = 20

CU + PU = 21

All-uses coverage = 95%



# 3 A detailed description of the testing strategy for the new unit test

For this assignment, our new testing strategy on developing and executing new units tests can be boiled down to a X steps.

**Step 1** - Run EclEmma on our Assignment 2 test cases (old tests)

**Step 2** - Investigate if these old test missed running lines in the source files. A missed line is indicated by red highlighting, while a line that was executed is indicated by green highlighting. Additionally, check to see the coverage stats that EclEmma produces (Instructions, Branches, Lines, Methods, Complexity)

**Step 3** - Based on the identified missing lines, modify the old unit tests

**Step 4** - Run EclEmma with the modified tests. Compare against the source code and look at the EclEmma stats once again. 

**Step 5** - Repeat Steps 2-4 until the minimum targets are satisfied.

# 4 A high level description of five selected test cases you have designed using coverage information, and how they have increased code coverage

#### 1. `RangeTest.getLowerBounds()`

Before adding test case `RangeTest.getLowerBounds()`, the coverage calculated using EclEmma was as mentioned in below table.

| Counter      | Coverage |
| ------------ | -------- |
| Instructions | 30.0%  |
| Branches     | 50.0 %   |
| Lines        | 40.0 %  |
| Methods      | 100.0 %  |
| Complexity   | 50.0 %   |

At first glance it appears that there s room for inprovment since branch coverage is only 50%.

When we analyze our test code coverage using EclEmma, we found that following condition is only partially covered

```java
 if (lower > upper){}
```

The branch not covered is when `lower > upper`.

To Try and improve coverage, a test case was added to `RangeTest.getlowerBounds()` where the `getLowerBounds` method is called with a range of (1,-1) so that `lower` (1) is greater then `upper` (-1).
However the issue with this is that within the range constructor the same condition is handled thus making it not possible to test the functionality of this branch of the `getLowerBound` method. It can be seen though that the `lower > upper` condition is called in the range constructor.

```java
public Range(double lower, double upper) {
        if (lower > upper) {
            String msg = "Range(double, double): require lower (" + lower
                + ") <= upper (" + upper + ").";
            throw new IllegalArgumentException(msg);
        }
        this.lower = lower;
        this.upper = upper;
    }
```
```java
public double getLowerBound() {
        if (lower > upper) {
            String msg = "Range(double, double): require lower (" + lower
                + ") <= upper (" + upper + ").";
            throw new IllegalArgumentException(msg);
        }
        return this.lower;
    };
    }
```

The best coverage possible is still the intiial coverage case.

| Counter      | Coverage |
| ------------ | -------- |
| Instructions | 30.0%  |
| Branches     | 50.0 %   |
| Lines        | 40.0 %  |
| Methods      | 100.0 %  |
| Complexity   | 50.0 %   |

#### 2. `Range.ExpandToIncludeTest()`

Prior to adding test case `RangeTest.ExpandToIncludeTest()`, the coverage calculated using EclEmma was as mentioned in the next table.

| Counter      | Coverage |
| ------------ | -------- |
| Instructions | 84.2%  |
| Branches     | 83.3 %   |
| Lines        | 85.7 %  |
| Methods      | 100.0 %  |
| Complexity   | 75.0 %   |

This method already has decent coverage compared to the previous one to start but we know that there are still some improvements. After you using EclEmma's code coverage tools, we determined that one of the `if` statments are not being executed:
```java
if (range == null) {
            return new Range(value, value);
        }
```

After adding an extra test case, the coverage percentages all shot up to 100%. We've successfully resolved the coverage deficit.

```java
@Test
    public void expandToIncludeNullRangeObj() {
    	double value = 5.0;
    	assertEquals("Failed to handle null value (should've been Range(value, value).", new Range(value, value), Range.expandToInclude(null, value));
    }
```

| Counter      | Coverage |
| ------------ | -------- |
| Instructions | 100.0 %  |
| Branches     | 100.0 %   |
| Lines        | 100.0 %  |
| Methods      | 100.0 %  |
| Complexity   | 100.0 %   |

# 5 A detailed report of the coverage achieved of each class and method (a screen shot from the code cover results in green and red color would suffice)

Text…

# 6 Pros and Cons of coverage tools used and Metrics you report

We tried to test all of the different coverage tools described in the assignment instructions.
Here is a list of the coverage tools that we tested and some notes for each one:

### ECLEmma:
- Provides comprehensive coverage metrics.
- Shows instruction coverage, branch coverage, line coverage, method coverage, type coverage, and complexity coverage
- Intuitive interface for understanding coverage results
  
### JaCoCo:
- Has the same features as EclEmma and there seem to be no differences
  
### Clover:
- Offers advanced features for identifying project risks and complex cases
- Has a dashboard view and code highlighting
  - It also highlights the top project risks, most complex cases and least tested methods in the dashboard view
- Provides detailed insights into code coverage and complexity
  - This includes the average number of paths per method and cyclomatic complexity
- Requires additional effort to set up and configure properly
- There are compatibility issues with certain project setups and environments and it was difficult to get this tool to work consistently
  
### CodeCover:
- When setting this up, we ran into this error:

  `Plug-in "org.codecover.eclipse" was unable to instantiate class "org.codecover.eclipse.junit.JUnitLaunchConfigurationDelegate".org/eclipse/osgi/framework/internal/core/BundleHost`

- After looking into this, it seems like this tool only works on the Eclipse Kepler version of Eclipse and therefore we did not look into this further since none of us had Eclipse Kepler installed

### Cobertura:
- We were unable to set this up as it was difficult to understand
- It does not have a native eclipse plugin, an external download is required
- Documentation is sparse and hard to navigate with some broken links

### Coverlipse:
- Latest release was in 2009 so it is outdated and we weren’t able to make it work with our versions of eclipse
- It was last compatible with Eclipse version 3.4, we were using using Eclipse 2023-12 R

After going through the various coverage tools, we as a team, decided to use ECLEmma as it offered statement (instruction) coverage, branch coverage and a suitable alternative for condition coverage, which was method coverage. It was also the easiest to use and worked well on all of our systems.

# 7 A comparison on the advantages and disadvantages of requirements-based test generation and coverage-based test generation.

### 7.1 - Requirements-Based Test Generation

Requirements-based test generation was performed by aligning the tests with the provided JavaDocs for the Range and DataUtilities classes of the SUT. The advantage of this approach was that each generated test could be clearly traced to the specific requirements. This provides a clear way to write tests that ensure that each method is acting as intended. We did however, run into issues when the documentation was unclear. For example, for the Range.combine() method, the documentation did not state how to handle the combination of two non-overlapping ranges. It was therefore not possible to write a test to handle this scenario as the intended result was unknown.

### 7.2 - Coverage-Based Test Generation

Coverage-based test generation was performed using EclEmma. The advantage of this approach is that it provided several metrics that could be reviewed and assessed. This provided a means of objectively improving several of the tests as noted in Section 5 by identifying and improving areas of the code that were not tested. It also provided a visual way of assessing the coverage of the code which allowed for easier group test review discussions. The disadvantage to this approach is that it does not necessarily ensure that the generated tests are correct; the metrics indicate coverage only and do not represent the quality of the tests being performed. It is therefore possible to achieve high coverage metrics with tests that do not adequately assess the functionality of the code.

# 8 A discussion on how the team work/effort was divided and managed

The team initially split off into two groups. One group was responsible for trying out each of the coverage tools (Section 3.1); the other was responsible for examining the manual measurement of data flow coverage (Section 3.2). Once complete, the entire group met and reviewed the work performed by the other group members.

In accordance with Section 3.3, each team member reviewed the code coverage of the tests they had generated in assignment 2 in accordance with the following table:

| JFreeChart method                                          | Tester                   |
| ---------------------------------------------------------- | ------------------------ |
| `Range.getLowerBound()`                                    | Jeremy Sugimoto          |
| `Range.combine(Range range1, Range range2)`                | Matt De Filippo          |
| `Range.expandToInclude(Range range, double value)`         | Redge Santillan          |
| `Range.contains(double value)`                             | Momin Muhammad           |
| `Range.equals(java.lang.Object obj)`                       | Shad Sajid               |
| `DataUtilities.calculateRowTotal(Values2D data, int row)`  | Jeremy Sugimoto          |
| `DataUtilities.getCumulativePercentages(KeyedValues data)` | Redge Santillan          |
| `DataUtilities.calculateColumnTotal(Values2D, int)`        | Momin Muhammad           |
| `DataUtilities.createNumberArray2D(double[][] data)`       | Matt De Filippo          |
| `DataUtilities.createNumberArray(double[] data)`           | Shad Sajid               |

Once reviewed each team member was responsible for reviewing and finding potential improvements to increase code coverage.

# 9 Any difficulties encountered, challenges overcome, and lessons learned from performing the lab

## Difficulties Encountered / Challenges Overcome

### Use of EclEmma

Initially, the team was a bit confused on how to use EclEmma to assess code covered for the specified class methods. Initially, we were looking at the coverage statistics for the test classes to check the coverage. We were also unsure of the specific meaning of the highlighted (green, yellow, red) text. Reviewing the EclEmma official documentation provided clarity on these issues and allowed us to use the tool effectively.

## Lessons Learned

...

# 10 Comments/feedback on the lab itself

The lab provided exposure to various code coverage tools which will be valuable in developing comprehensive tests going forward.

The assignment document was sufficiently detailed to complete all required tasks. There were however, some issues encountered with some of the provided coverage tools (as noted in Section 6). These could perhaps be updated to more appropriate coverage tools.
