**SENG 637 - Software Testing, Reliability, and Quality**

**Lab. Report \#3 – Requirements-Based Test Generation**

| Group: 22      |
|-----------------|
| Student 1 Jeremy Sugimoto                |   
| Student 2 Matt De Filippo             |   
| Student 3 Momin Muhammad               |   
| Student 4 Redge Santillan                |   
| Student 5 Shad Sajid               |   

# Table of Contents

1. [Introduction](#1-introduction)
2. [Manual data-flow coverage calculations for Range.getLowerBounds and DataUtilities.CalculateColumnTotal methods](#2-manual-data-flow-coverage-calculations-for-rangetgetlowerbounds-and-datautilitiescalculatecolumntotal-methods)
3. [A detailed description of the testing strategy for the new unit test](#3-a-detailed-description-of-the-testing-strategy-for-the-new-unit-test)
4. [A high level description of five selected test cases you have designed using coverage information, and how they have increased code coverage](#4-a-high-level-description-of-five-selected-test-cases-you-have-designed-using-coverage-information-and-how-they-have-increased-code-coverage)
5. [A detailed report of the coverage achieved of each class and method (a screen shot from the code cover results in green and red color would suffice)](#5-a-detailed-report-of-the-coverage-achieved-of-each-class-and-method-a-screen-shot-from-the-code-cover-results-in-green-and-red-color-would-suffice)
6. [Pros and Cons of coverage tools used and Metrics you report](#6-pros-and-cons-of-coverage-tools-used-and-metrics-you-report)
7. [A comparison on the advantages and disadvantages of requirements-based test generation and coverage-based test generation](#7-a-comparison-on-the-advantages-and-disadvantages-of-requirements-based-test-generation-and-coverage-based-test-generation)
8. [A discussion on how the team work/effort was divided and managed](#8-a-discussion-on-how-the-team-workeffort-was-divided-and-managed)
9. [Any difficulties encountered, challenges overcome, and lessons learned from performing the lab](#9-any-difficulties-encountered-challenges-overcome-and-lessons-learned-from-performing-the-lab)
10. [Comments/feedback on the lab itself](#10-commentsfeedback-on-the-lab-itself)



# 1 Introduction

Text…

# 2 Manual data-flow coverage calculations for Range.getLowerBounds and DataUtilities.CalculateColumnTotal methods

`Range.getLowerBounds()`

![image](https://github.com/rrsantillan/seng637-a3-group22/assets/132379865/253eb08d-ccd6-48b8-8c6d-6d80af983d96)


##### Defs, uses, and du-pairs

|               |                                |
| ------------- | ------------------------------ |
| **defs**:     | def(2) = {msg}              |
| **uses**:     | use(1) = {lower,upper}      |
|               | use(2) = {lower,upper}      |
|               | use(3) = {msg}      |
|               | use(4) = {lower}      |
| **du-pairs**: | for msg: (2,3) |
|               | for lower: (1,2),(1,4)|
|               | for upper: (1,2),(1,4)|


#### DU-pair coverage calculations per test case
| Variable | Def at node (n) | dcu(v,n) | dpu(v,n)  |
|----------|-----------------|----------|-----------|
|   lower  | Prior to function|        |   (1,2),(1,4)  |       
|   upper  | Prior to function|        |   (1,2),(1,4)  |
|   msg    |        2        |   (2,3)  |           |


| Test Case | Execution path | DU-pairs covered | CUc + PUc | All uses coverage % |
|-----------------------------|------------------|------------------|-----------|---------------------|
|`lowerBoundShouldBeNegativeTen`| (1,4)            |      (1,4)        |     (1,4)      |        33.33%             |
|`lowerBoundWithLargeRange`     | (1,4)            |      (1,4)       |      (1,4)     |     33.33%                |
|`shouldThrowExceptionWhenLowerIsGreaterThanUpper` |     (1,2,3)       | (2,3)| (1,2),(2,3) | 66.66%  |

#### Total

Cuc + PUc = 3

CU +PU = 3

All-uses coverage = 100%

#### 2. `DataUtilities.calculateColumnTotal(Values2D data, int column)`

![image](https://github.com/rrsantillan/seng637-a3-group22/assets/132379865/afd48c53-f22d-4f32-aa1e-9c0f16fe6d93)



##### Defs, uses, and du-pairs

|               |                                                       |
| ------------- | ----------------------------------------------------- |
| **defs**:     | def(1) = {data, column}                               |
|               | def(3) = {total, rowCount, r}                         |
|               | def(5) = {n}                                          |
|               | def(6) = {total}                                      |
|               | def(7) = {r}                                          |
| **uses**:     | use(2) = {data}                                       |
|               | use(3) = {data}                                       |
|               | use(4) = {r, rowCount}                                |
|               | use(5) = {data, r, column, n}                         |
|               | use(6) = {total, n}                                   |
|               | use(7) = {r}                                          |
|               | use(8) = {total}                                      |
| **du-pairs**: | for data: (1, 2), (1, 3), (1, 5)                      |
|               | for column: (1, 5)                                    |
|               | for total: (3, 6), (3, 8), (6, 6), (6, 8)             |
|               | for rowCount: (3, 4)                                  |
|               | for r: (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7) |
|               | for n: (5, 5), (5, 6)                                 |

##### DU-pair coverage calculation per test case

| Variable | Def at node (n) | dcu(v, n) | dpu(v, n)        |
| -------- | --------------- | --------- | ---------------- |
| data     | 1               | {2, 3, 5} | {}               |
| column   | 1               | {5}       | {}               |
| r        | 3               | {5, 7}    | {(4, 5), (4, 8)} |
| r        | 7               | {5, 7}    | {(4, 5), (4, 8)} |
| rowCount | 3               | {}        | {(4, 5), (4, 8)} |
| total    | 3               | {6, 8}    | {}               |
| total    | 6               | {6, 8}    | {}               |
| n        | 5               | {6}       | {(5, 6), (5, 7)} |
|          | Total           | CU = 13   | PU = 8           |

| Test case                                        | Execution path                                   | DU-pairs covered                                                                                                                       | CUc + PUc                                                                                                 | All-uses coverage % |
| ------------------------------------------------ | ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- | ------------------- |
| `calculateColumnTotalAllRowsFirstColumn`         | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalAllRowsMiddleColumn`        | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalAllRowsLastColumn`          | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalWithMaxValueAndFirstColumn` | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalWithMinValueAndFirstColumn` | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalWithMaxValueColumn`         | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalWithMinValueColumn`         | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |
| `calculateColumnTotalWithSumOf0AndFirstColumn`   | [1, 2, 3, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 8] | (1, 2), (1, 3), (1, 5), (1, 5), (3, 6), (3, 8), (6, 6), (6, 8), (3, 4), (3, 4), (3, 5), (3, 7), (7, 4), (7, 5), (7, 7), (5, 5), (5, 6) | {2,3,5}, {5}, {5, 7}, {5, 7}, {6, 8}, {6, 8}, {6}, (4, 5), (4, 8), (4, 5), (4, 8), (4, 5), (4, 8), (5, 6) | 95%                 |

**Total**

CUc + PUc = 20

CU + PU = 21

All-uses coverage = 95%



# 3 A detailed description of the testing strategy for the new unit test

For this assignment, our new testing strategy on developing and executing new units tests can be boiled down to a X steps.

**Step 1** - Run EclEmma on our Assignment 2 test cases (old tests)

**Step 2** - Investigate if these old test missed running lines in the source files. A missed line is indicated by red highlighting, while a line that was executed is indicated by green highlighting. Additionally, check to see the coverage stats that EclEmma produces (Instructions, Branches, Lines, Methods, Complexity)

**Step 3** - Based on the identified missing lines, modify the old unit tests

**Step 4** - Run EclEmma with the modified tests. Compare against the source code and look at the EclEmma stats once again. 

**Step 5** - Repeat Steps 2-4 until the minimum targets are satisfied.

# 4 A high level description of five selected test cases you have designed using coverage information, and how they have increased code coverage

#### 1. `RangeTest.getLowerBounds()`

Before adding test case `RangeTest.getLowerBounds()`, the coverage calculated using EclEmma was as mentioned in below table.

| Counter      | Coverage |
| ------------ | -------- |
| Instructions | 30.0%  |
| Branches     | 50.0 %   |
| Lines        | 40.0 %  |
| Methods      | 100.0 %  |
| Complexity   | 50.0 %   |

At first glance it appears that there s room for inprovment since branch coverage is only 50%.

When we analyze our test code coverage using EclEmma, we found that following condition is only partially covered

```java
 if (lower > upper){}
```

The branch not covered is when `lower > upper`.

To Try and improve coverage, a test case was added to `RangeTest.getlowerBounds()` where the `getLowerBounds` method is called with a range of (1,-1) so that `lower` (1) is greater then `upper` (-1).
However the issue with this is that within the range constructor the same condition is handled thus making it not possible to test the functionality of this branch of the `getLowerBound` method. It can be seen though that the `lower > upper` condition is called in the range constructor.

```java
public Range(double lower, double upper) {
        if (lower > upper) {
            String msg = "Range(double, double): require lower (" + lower
                + ") <= upper (" + upper + ").";
            throw new IllegalArgumentException(msg);
        }
        this.lower = lower;
        this.upper = upper;
    }
```
```java
public double getLowerBound() {
        if (lower > upper) {
            String msg = "Range(double, double): require lower (" + lower
                + ") <= upper (" + upper + ").";
            throw new IllegalArgumentException(msg);
        }
        return this.lower;
    };
    }
```

The best coverage possible is still the intiial coverage case.

| Counter      | Coverage |
| ------------ | -------- |
| Instructions | 30.0%  |
| Branches     | 50.0 %   |
| Lines        | 40.0 %  |
| Methods      | 100.0 %  |
| Complexity   | 50.0 %   |

#### 2. `Range.ExpandToIncludeTest()`

Prior to adding test case `RangeTest.ExpandToIncludeTest()`, the coverage calculated using EclEmma was as mentioned in the next table.

| Counter      | Coverage |
| ------------ | -------- |
| Instructions | 84.2%  |
| Branches     | 83.3 %   |
| Lines        | 85.7 %  |
| Methods      | 100.0 %  |
| Complexity   | 75.0 %   |

This method already has decent coverage compared to the previous one to start but we know that there are still some improvements. After you using EclEmma's code coverage tools, we determined that one of the `if` statments are not being executed:
```java
if (range == null) {
            return new Range(value, value);
        }
```

After adding an extra test case, the coverage percentages all shot up to 100%. We've successfully resolved the coverage deficit.

```java
@Test
    public void expandToIncludeNullRangeObj() {
    	double value = 5.0;
    	assertEquals("Failed to handle null value (should've been Range(value, value).", new Range(value, value), Range.expandToInclude(null, value));
    }
```

| Counter      | Coverage |
| ------------ | -------- |
| Instructions | 100.0 %  |
| Branches     | 100.0 %   |
| Lines        | 100.0 %  |
| Methods      | 100.0 %  |
| Complexity   | 100.0 %   |

# 5 A detailed report of the coverage achieved of each class and method (a screen shot from the code cover results in green and red color would suffice)

Text…

# 6 Pros and Cons of coverage tools used and Metrics you report

We tried to test all of the different coverage tools described in the assignment instructions.
Here is a list of the coverage tools that we tested and some notes for each one:

### ECLEmma:
- Provides comprehensive coverage metrics.
- Shows instruction coverage, branch coverage, line coverage, method coverage, type coverage, and complexity coverage
- Intuitive interface for understanding coverage results
  
### JaCoCo:
- Has the same features as EclEmma and there seem to be no differences
  
### Clover:
- Offers advanced features for identifying project risks and complex cases
- Has a dashboard view and code highlighting
  - It also highlights the top project risks, most complex cases and least tested methods in the dashboard view
- Provides detailed insights into code coverage and complexity
  - This includes the average number of paths per method and cyclomatic complexity
- Requires additional effort to set up and configure properly
- There are compatibility issues with certain project setups and environments and it was difficult to get this tool to work consistently
  
### CodeCover:
- When setting this up, we ran into this error:

  `Plug-in "org.codecover.eclipse" was unable to instantiate class "org.codecover.eclipse.junit.JUnitLaunchConfigurationDelegate".org/eclipse/osgi/framework/internal/core/BundleHost`

- After looking into this, it seems like this tool only works on the Eclipse Kepler version of Eclipse and therefore we did not look into this further since none of us had Eclipse Kepler installed

### Cobertura:
- We were unable to set this up as it was difficult to understand
- It does not have a native eclipse plugin, an external download is required
- Documentation is sparse and hard to navigate with some broken links

### Coverlipse:
- Latest release was in 2009 so it is outdated and we weren’t able to make it work with our versions of eclipse
- It was last compatible with Eclipse version 3.4, we were using using Eclipse 2023-12 R

After going through the various coverage tools, we as a team, decided to use ECLEmma as it offered statement (instruction) coverage, branch coverage and a suitable alternative for condition coverage, which was method coverage. It was also the easiest to use and worked well on all of our systems.

# 7 A comparison on the advantages and disadvantages of requirements-based test generation and coverage-based test generation.

Text…

# 8 A discussion on how the team work/effort was divided and managed

Text…

# 9 Any difficulties encountered, challenges overcome, and lessons learned from performing the lab

One major hurdle we encountered involved mastering code coverage tools like EclEmma. Initially, understanding these tools' operations proved difficult. We struggled to identify the specific run's coverage data or erroneously analyzed the unit tests' coverage. However, these challenges were overcome through collaborative efforts to learn the correct application of EclEmma.

# 10 Comments/feedback on the lab itself

Text…
